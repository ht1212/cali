#' Calibrate using non-linear model
#'
#' @param parameters Other malariasimulation model parameters
#' @param target Values of target variable to calibrate to.
#' @param target_tt Timesteps of target.
#' @param ncores Number of cpu cores to perform simulations on in parallel
#' @param nsims Number of simulations to run
#' @param summary_function A function that produces a vector of the target variable.
#'
#' @return A list of data from simulation runs, predicted EIR value for calibration targets, the fit of the non-linear model object
#' @export
#'
#' @examples
nlcali <- function(parameters, 
                   target, 
                   target_tt,
                   summary_function,
                   ncores = 1,
                   nsims = 100) {
  
  # Range of EIR values to be test
  test_EIRs <- exp(seq(-3, 6, length.out = nsims))
  
  # Simulate runs for each EIR value to be tested
  sim_data <- run_simulations(parameters = parameters,
                                      target = target,
                                      target_tt = target_tt,
                                      ncores = ncores,
                                      test_EIRs = test_EIRs,
                              summary_function = summary_function)
  
  # Fit spline model to simulation output
  mod_res <- fit_spline(sim_data = sim_data,
                                target = target)
  
  return(list(sims = sim_data, eir_pred = mod_res$pred, fit = mod_res$spline, mod = mod_res$mod))
}

#' Run simulations from malariasimuation
#'
#' @param parameters Other malariasimulation model parameters
#' @param target Values of target variable to calibrate to.
#' @param target_tt Timesteps of target.
#' @param test_EIRs A vector of EIR values to use in the simulations
#' @param ncores Number of simulations to run
#' @param summary_function A function that produces a vector of the target variable.
#' @return A data.table of simulation results
#' @importFrom parallel detectCores makeCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom foreach getDoParRegistered foreach %dopar%
#' @importFrom data.table data.table rbindlist
#' @importFrom malariasimulation set_equilibrium run_simulation
#'
#' @examples
run_simulations <- function(parameters, target, target_tt, test_EIRs, ncores, summary_function) {
  
  # Set up cores for parallel runs
  print("Setting up cores for simulation runs")
  my.cluster <- parallel::makeCluster(
    ncores,
    type = "PSOCK"
  )
  
  print(my.cluster)
  doParallel::registerDoParallel(cl = my.cluster)
  
  print(paste0("Cluster registered: ", foreach::getDoParRegistered()))
  print(paste0("Simulating from ", foreach::getDoParWorkers(), " cores"))
  
  # Create function that will run the model for a specific EIR
  run_func <- function(x){
    p <- malariasimulation::set_equilibrium(parameters, init_EIR = x)
    raw_output <- malariasimulation::run_simulation(timesteps = max(target_tt), parameters = p)
    out <- summary_function(raw_output)[target_tt]
    return(out)
  }
  
  # Perform runs in parallel
  ll <- foreach::foreach(i = 1:length(test_EIRs)) %dopar% {
    data.table::data.table(eir = test_EIRs[i],
                           prev = run_func(test_EIRs[i]),
                           timepoint = 1:length(target_tt))
  }
  
  # Convert output into data.table
  out <- data.table::rbindlist(ll)
  
  # Can't have fully 0 prevalence into logit model
  out[prev == 0, prev := 0.005]
  
  # Turn off clusters
  parallel::stopCluster(cl = my.cluster)
  
  return(out)
}

#' Fit non-linear spline model to simulation data
#'
#' @param sims data.table of simulation output generated by run_simulations
#' @param target Values of target variable to calibrate to.
#'
#' @return A list of a data.table of predicted EIR values for a range of prevalences, predicted EIR values for specific target values, the spline model fit
#' @importFrom mgcv gam rmvn
#' @importFrom data.table data.table copy as.data.table
#' @importFrom boot logit inv.logit
#'
#' @examples
fit_spline <- function(sim_data, target){
  
  # Re-format simulation data into wide format
  dat <- data.table::copy(sim_data)
  cols <- paste0("prev", 1:length(target))
  dat <- dat[, (cols) := as.list(.SD[,prev]), by = "eir"]
  dat <- dat[timepoint == 1, ]
  dat[, prev := NULL]
  dat[, timepoint := NULL]
  
  # Transform data to give roughly linear relationship
  dat[, (cols) := lapply(.SD, boot::logit), .SDcols = cols]
  dat[, eir := log(eir)]
  
  # Generate relevant formula depending on number of targets
  form <- paste0("eir ~ s(prev1)",
                 ifelse(length(target) > 1,
                        paste0(" + s(prev",
                               2:length(target),
                               ")", collapse = ""), ""))
  
  # Fit spline model
  m <- mgcv::gam(data = dat, formula = as.formula(form))
  
  # Generate prevalence values to predict starting_EIR for
  xseq <- boot::logit(seq(min(sim_data$prev), max(sim_data$prev), 0.01))
  targ <- ifelse(target == 0, 0.0001, target)
  
  if(length(target) == 1){
    pred_df <- data.frame(prev1 = xseq)
    # Add specific prediction values to the end of the data.frame
    pred_df <- rbind(pred_df, data.frame(prev1 = boot::logit(targ)))
  }else if(length(target)  == 2){
    pred_df <- data.frame(expand.grid(xseq, xseq))
    colnames(pred_df) <- cols
    # Add specific prediction values to the end of the data.frame
    tar_df <- pred_df[1,]
    tar_df[1, ] <- boot::logit(targ)
    pred_df <- rbind(pred_df, tar_df)
  }else if(length(target) > 2){
    pred_df <- as.data.frame(matrix(boot::logit(targ), 
                      nrow = 1, 
                      ncol = length(target), 
                      byrow = TRUE))
    colnames(pred_df) <- cols
  }
  
  # Generate simultaneous confidence intervals
  # https://fromthebottomoftheheap.net/2016/12/15/simultaneous-interval-revisited/
  
  Vb <- vcov(m)
  pred <- predict(m, pred_df, se.fit = TRUE)
  se.fit <- pred$se.fit
  BUdiff <- mgcv::rmvn(n = 10000, mu = rep(0, nrow(Vb)), V = Vb)
  Cg <- predict(m, pred_df, type = "lpmatrix")
  simDev <- Cg %*% t(BUdiff)
  absDev <- abs(sweep(simDev, 1, se.fit, FUN = "/"))
  masd <- apply(absDev, 2L, max)
  crit <- quantile(masd, prob = 0.95, type = 8)
  out <- data.table::as.data.table(transform(cbind(data.frame(pred), pred_df),
                                             upr = fit + (crit * se.fit),
                                             lwr = fit - (crit * se.fit)))
  
  
  # Format output back into real values
  out[, (cols) := lapply(.SD, boot::inv.logit), .SDcols = cols]
  cols2 <- c("fit", "upr", "lwr")
  out[, (cols2) := lapply(.SD, exp), .SDcols = cols2]
  colnames(out)[colnames(out) == "fit"] <- "eir"
  
  # Separate specific values to be predicted
  pred <- out[nrow(out),]
  out <- out[- nrow(out), ]
  
  return(list(spline = out, pred = pred, mod = m))
}


#' Simulate from calibrated EIR value and calculate continuous ranked probability score
#'
#' @param out_EIR fitted EIR from a cali or ncali run
#' @param parameters Other malariasimulation model parameters
#' @param target Values of target variable to calibrate to.
#' @param target_tt Timesteps of target.
#' @param ncores Number of cpu cores to perform simulations on in parallel
#' @param nsims Number of simulations to run
#' @param summary_function A function that produces a vector of the target variable.
#'
#' @return
#' @export
#' @importFrom scoringutils crps_sample
#' @data.table data.table
#'
#' @examples
score_calibration <- function(out_EIR, 
                              parameters,
                              target, 
                              target_tt,
                              ncores = 1,
                              nsims = 100,
                              summary_function){
  
  runs <- run_simulations(parameters = parameters, 
                                 target = target, 
                                 target_tt = target_tt, 
                                 test_EIRs = rep(out_EIR, nsims), 
                                 ncores = ncores, 
                                 summary_function = summary_function)
  
  pred_matrix <- matrix(NA, nrow = length(target), ncol = nsims)
  
  for(i in 1:length(target)){
    pred_matrix[i, ] <- runs[timepoint == i, prev]
  }
  
  scores <- scoringutils::crps_sample(true_values = target, predictions = pred_matrix)
  
  out <- data.table::data.table(target = target, crps = scores)
  
  return(out)
}