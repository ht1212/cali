#' Calibrate using non-linear model
#'
#' @param parameters Other malariasimulation model parameters
#' @param target Values of target variable to calibrate to.
#' @param target_tt Timesteps of target.
#' @param ncores Number of cpu cores to perform simulations on in parallel
#' @param nsims Number of simulations to run
#' @param summary_function A function that produces a vector of the target variable.
#'
#' @return A list of data from simulation runs, predicted EIR value for calibration targets, the fit of the non-linear model object
#' @export
#'
#' @examples
nlcali <- function(parameters, 
                   target, 
                   target_tt,
                   summary_function,
                   change_function,
                   par_name = "init_EIR",
                   summary_name = "prev",
                   interval = c(0, 300),
                   ncores = 1,
                   nsims = 100,
                   trans.par = exp,
                   inv.trans.par = log,
                   trans.summary = boot::logit,
                   inv.trans.summary = boot::inv.logit,
                   ...) {
  
  # Simulate runs for each EIR value to be tested
  sim_data <- run_simulations(parameters = parameters,
                              par_name = par_name, 
                              summary_name = summary_name,
                              target = target,
                              target_tt = target_tt,
                              ncores = ncores,
                              nsims = nsims,
                              interval = interval,
                              summary_function = summary_function,
                              change_function = change_function,
                              ...)
  
  # Fit spline model to simulation output
  mod_res <- fit_spline(sim_data = sim_data,
                               target = target, 
                               par_name = par_name, 
                               summary_name = summary_name)
  
  return(list(sims = sim_data, target_pred = mod_res$pred, fit = mod_res$spline, mod = mod_res$mod))
}

#' Run simulations from malariasimuation
#'
#' @param parameters Other malariasimulation model parameters
#' @param target Values of target variable to calibrate to.
#' @param target_tt Timesteps of target.
#' @param test_EIRs A vector of EIR values to use in the simulations
#' @param ncores Number of simulations to run
#' @param summary_function A function that produces a vector of the target variable.
#' @export
#' @return A data.table of simulation results
#' @importFrom parallel detectCores makeCluster
#' @importFrom doParallel registerDoParallel
#' @importFrom foreach getDoParRegistered foreach %dopar%
#' @importFrom data.table data.table rbindlist
#' @importFrom malariasimulation set_equilibrium run_simulation
#'
#' @examples
run_simulations <- function(parameters,
                            target,
                            target_tt,
                            interval,
                            nsims,
                            par_name = "init_EIR",
                            summary_name = "prev",
                            ncores,
                            summary_function,
                            change_function,
                            ...) {
  
  # Range of values to test
  test_values <- seq(interval[1], interval[2], length.out = nsims)
  
  # Set up cores for parallel runs
  print("Setting up cores for simulation runs")
  my.cluster <- parallel::makeCluster(
    ncores,
    type = "PSOCK"
  )
  
  print(my.cluster)
  doParallel::registerDoParallel(cl = my.cluster)
  
  print(paste0("Cluster registered: ", foreach::getDoParRegistered()))
  print(paste0("Simulating from ", foreach::getDoParWorkers(), " cores"))
  
  # Perform runs in parallel
  ll <- foreach::foreach(i = 1:length(test_values)) %dopar% {
    data.table::data.table(test_value = test_values[i],
                           sim_value = summary_function(malariasimulation::run_simulation(timesteps = max(target_tt), parameters = change_function(x = test_values[i], parameters = parameters, par_name = par_name),...))[target_tt],
                           timepoint = 1:length(target_tt))
  }
  
  # Convert output into data.table
  out <- data.table::rbindlist(ll)
  
  # Can't have fully 0 or 1 prevalence into logit model
  out[sim_value == 0, sim_value := 0.001]
  out[sim_value == 1, sim_value := 0.999]
  
  # Turn off clusters
  parallel::stopCluster(cl = my.cluster)
  
  colnames(out)[colnames(out) == "sim_value"] <- summary_name
  colnames(out)[colnames(out) == "test_value"] <- par_name
  
  return(out)
}

#' Fit non-linear spline model to simulation data
#'
#' @param sims data.table of simulation output generated by run_simulations
#' @param target Values of target variable to calibrate to.
#'
#' @return A list of a data.table of predicted EIR values for a range of prevalences, predicted EIR values for specific target values, the spline model fit
#' @importFrom mgcv gam rmvn
#' @importFrom data.table data.table copy as.data.table
#' @importFrom boot logit inv.logit
#'
#' @examples
fit_spline <- function(sim_data, 
                       target, 
                       par_name, 
                       summary_name){
  
  # Re-format simulation data into wide format
  dat <- data.table::copy(sim_data)
  cols <- paste0(summary_name, 1:length(target))
  
  z <- data.table::data.table(x = unique(dat[, ..par_name]))
  colnames(z) <- par_name
  for(i in 1:length(target)){
    z[, (cols[i]) := dat[timepoint == i, summary_name, with = FALSE]]
  }
  
  # Transform data to give roughly linear relationship
  z[, (cols) := lapply(.SD, trans.summary), .SDcols = cols]
  z[, (par_name) := lapply(.SD, trans.par), .SDcols = par_name]
  
  # Generate relevant formula depending on number of targets
  form <- paste0(par_name," ~ s(",summary_name,"1)",
                 ifelse(length(target) > 1,
                        paste0(" + s(",summary_name,
                               2:length(target),
                               ")", collapse = ""), ""))
  
  # Fit spline model
  m <- mgcv::gam(data = z, 
                 formula = as.formula(form), 
                 method = "REML")
  
  # Generate prevalence values to predict starting_EIR for
  xseq <- trans.summary(seq(min(sim_data[, ..summary_name]), 
                            max(sim_data[, ..summary_name]), 
                            0.01))
  targ <- trans.summary(ifelse(target == 0, 0.001, target))
  
  if(length(target) == 1){
    
    pred_df <- data.frame(xseq)
    # Add specific prediction values to the end of the data.frame
    tar_df <- data.frame(xseq = targ)
    pred_df <- rbind(pred_df, tar_df)
    colnames(pred_df) <- paste0(summary_name, "1")
    
  }else if(length(target)  == 2){
    
    pred_df <- data.frame(expand.grid(xseq, xseq))
    colnames(pred_df) <- cols
    # Add specific prediction values to the end of the data.frame
    tar_df <- pred_df[1,]
    tar_df[1, ] <- targ
    pred_df <- rbind(pred_df, tar_df)
    
  }else if(length(target) > 2){
    
    pred_df <- as.data.frame(matrix(targ, 
                      nrow = 1, 
                      ncol = length(target), 
                      byrow = TRUE))
    colnames(pred_df) <- cols
    
  }
  
  # Generate simultaneous confidence intervals
  # https://fromthebottomoftheheap.net/2016/12/15/simultaneous-interval-revisited/
  
  Vb <- vcov(m)
  pred <- predict(m, pred_df, se.fit = TRUE)
  se.fit <- pred$se.fit
  BUdiff <- mgcv::rmvn(n = 10000, mu = rep(0, nrow(Vb)), V = Vb)
  Cg <- predict(m, pred_df, type = "lpmatrix")
  simDev <- Cg %*% t(BUdiff)
  absDev <- abs(sweep(simDev, 1, se.fit, FUN = "/"))
  masd <- apply(absDev, 2L, max)
  crit <- quantile(masd, prob = 0.95, type = 8)
  out <- data.table::as.data.table(transform(cbind(data.frame(pred), pred_df),
                                             upr = fit + (crit * se.fit),
                                             lwr = fit - (crit * se.fit)))
  
  
  # Format output back into real values
  out[, (cols) := lapply(.SD, inv.trans.summary), .SDcols = cols]
  cols2 <- c("fit", "upr", "lwr")
  out[, (cols2) := lapply(.SD, inv.trans.par), .SDcols = cols2]
  colnames(out)[colnames(out) == "fit"] <- par_name
  
  # Separate specific values to be predicted
  pred <- out[nrow(out), ]
  out <- out[-nrow(out), ]
  
  return(list(spline = out, pred = pred, mod = m))
}


#' Simulate from parameters using calibrated value and calculate continuous ranked probability score
#'
#' @param parameters Other malariasimulation model parameters
#' @param target Values of target variable to calibrate to.
#' @param target_tt Timesteps of target.
#' @param ncores Number of cpu cores to perform simulations on in parallel
#' @param nsims Number of simulations to run
#' @param summary_function A function that produces a vector of the target variable.
#'
#' @return
#' @export
#' @importFrom scoringutils crps_sample
#' @importFrom data.table as.data.table
#' @importFrom malariasimulation run_simulation_with_repetitions
#'
#' @examples
score_calibration <- function(parameters,
                              target, 
                              target_tt,
                              nsims = 100,
                              summary_function){
  
  runs <- malariasimulation::run_simulation_with_repetitions(timesteps = max(target_tt), 
                                                             repetitions = nsims, 
                                                             overrides = parameters, 
                                                             parallel = TRUE)

  df <-data.table::as.data.table(runs)[, .(timestep, sf = summary_function(.SD)), by = "repetition"
                            ][timestep %in% target_tt]
  
  pred_matrix <- matrix(NA, nrow = length(target), ncol = nsims)
  
  for(i in 1:length(target)){
    pred_matrix[i, ] <- df[timestep == target_tt[i], sf]
  }
  
  scores <- scoringutils::crps_sample(true_values = target, predictions = pred_matrix)
  
  out <- data.table::data.table(target = target, crps = scores)
  
  return(list(score = out, sims = df))
}

#' Default change function that varies EIR
#'
#' @param x 
#' @param parameters 
#' @param par_name 
#'
#' @return
#' @export
#'
#' @examples
eir_change <- function(x, parameters, par_name){
  parameters <- malariasimulation::set_equilibrium(parameters = parameters, 
                                                   init_EIR = x)
  return(parameters)
}


#' Default change function for standard parameters
#'
#' @param x 
#' @param parameters 
#' @param par_name 
#'
#' @return
#' @export
#'
#' @examples
default_change <- function(x, parameters, par_name){
  parameters[[par_name]] <- x
  return(parameters)
}